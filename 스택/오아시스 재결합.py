'''
문제
오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.

이 역사적인 순간을 맞이하기 위해 줄에서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해졌다.

두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.

줄에 서 있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)

둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 231 나노미터 보다 작다.

사람들이 서 있는 순서대로 입력이 주어진다.

출력
서로 볼 수 있는 쌍의 수를 출력한다.
'''
import sys

N = int(sys.stdin.readline())

humans = []

for i in range(N):
    tmp = int(sys.stdin.readline())
    humans.append(tmp)

stack = []
result = 0
same = 0 # 같은 숫자 세기용 스택


'''
첫 번째 반복문
스택에 남는 기준 
-> 
1. 내 우측에는 나보다 큰 수가 없을 것
2. 내 우측에 나보다 작은 수는 내가 잡아먹을 것
2-1. 다만 나보다 작은 수 이더라도 나(8)와 그 수(5) 사이에 B보다 큰 수가 있다면(8,6,5) 8은 6만을 세야함
2-2. 내 우측에 있는 나보다 작은 수가 여러개 존재할 경우 스택을 쌓아 덧셈
'''
for i in range(N):
    while stack:
        print(f'result: {result}', end=', ')
        print(stack, humans[i])
        if stack[-1][0] < humans[i]:
            # 7 7 8 6 5 3 7 4 7 7 10 6 1 2 
            stack[-1][1] += 1 # 자신을 팝 시키는 큰 수 -> +1
            result += stack[-1][1] + same # 자신이 셀 수 있는 수 + 자신과 값이 같은 수
            tmp = stack.pop()
            if stack: # 스택이 남아있다면
                if stack[-1][0] == tmp[0]: # 스택의 탑과 방금 팝한 수가 같다면
                    same += 1 # 스택 쌓기
                elif stack[-1][0] > tmp[0]:  # 스택의 탑이 방금 팝한 수보다 크다면
                    stack[-1][1] += 1 + same # 방금 팝한 수(1) + 쌓은 같은 수 스택
                    same = 0
            else: # 스택이 비었다면 같은 수 스택 초기화
                same = 0
        else:
            break
    stack.append([humans[i], 0]) # [사람 키, 볼 수 있는 사람의 수]

print(result)
print(stack)

# 5 5 2 2 5의 경우 각각 자신보다 작은 수를 잡아먹은 스택의 결과가 도출됨
# [[5, 0], [5, 2], [5, 0]]


# 위의 반복문과 비슷한 방식으로 같은 수 스택을 쌓아 결과를 계산
tmp = stack.pop()
same = 0
while stack:
    print(f'stack:{stack} (?) pop:{tmp}')
    if stack:
        if stack[-1][0] == tmp[0]:
            same += 1
        elif stack[-1][0] > tmp[0]:
            stack[-1][1] += 1 + same
            same = 0
        result += stack[-1][1] + same
    tmp = stack.pop()

print(result)

# -> *5* + [[10, 0], [9, 2], [8, 2], [8, 1], [8, 0]](12)
# (0+1) + (2+3) + (2+2) + (1+1) + 0 = 1+5+4+2

'''
5 5 2 2 5 -> 8
-> *3* + [[5, 0], [5, 2], [5, 0]](5)
[o] 8

14
7 7 8 6 5 3 7 4 7 7 10 6 1 2 
-> *22* +[[10, 0], [6, 1], [2, 0]](3)
[o] 25

10
10 9 1 3 8 6 7 8 5 8
-> *5* + [[10, 0], [9, 2], [8, 2], [8, 1], [8, 0]](12)
[o] 17
'''